<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TJA Decomposition Tool (Dan-i Optimized)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; background-color: #f4f6f8; line-height: 1.6; }
        .container { background-color: white; padding: 2.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h1 { color: #2d3748; margin-bottom: 0.5rem; text-align: center; }
        p.desc { text-align: center; color: #718096; margin-bottom: 2rem; font-size: 0.95rem; }
        
        .upload-area { 
            padding: 2rem; border: 2px dashed #cbd5e0; border-radius: 8px; background-color: #f8fafc; 
            text-align: center; transition: all 0.2s;
        }
        .upload-area:hover { border-color: #4299e1; background-color: #ebf8ff; }
        
        input[type="file"] { display: none; }
        .custom-file-upload {
            display: inline-block; padding: 12px 24px; cursor: pointer;
            background-color: #4a5568; color: white; border-radius: 6px; font-weight: bold;
            transition: background 0.2s;
        }
        .custom-file-upload:hover { background-color: #2d3748; }

        #fileNameDisplay { margin: 1rem 0; font-weight: bold; color: #3182ce; min-height: 1.5em; }

        #processBtn {
            background-color: #3182ce; color: white; border: none; padding: 14px 40px; 
            font-size: 1.1rem; font-weight: bold; border-radius: 6px; cursor: pointer; 
            transition: background-color 0.2s; display: none; margin: 10px auto;
        }
        #processBtn:hover { background-color: #2b6cb0; }

        #logArea {
            margin-top: 2rem; padding: 1rem; background-color: #2d3748; color: #a0aec0;
            border-radius: 6px; font-family: monospace; font-size: 0.85rem;
            max-height: 300px; overflow-y: auto; text-align: left; display: none;
        }
        .log-info { color: #63b3ed; }
        .log-success { color: #68d391; }
        .log-warn { color: #f6e05e; }
        .log-error { color: #fc8181; }
        .log-removed { color: #a0aec0; font-style: italic; }

        .footer { margin-top: 2rem; font-size: 0.8rem; color: #a0aec0; text-align: center; }
    </style>
</head>
<body>

<div class="container">
    <h1>TJA Decomposition Tool</h1>
    <p class="desc">æ®µä½TJAã‚’è§£æã—ã€EXAMç­‰ã‚’å‰Šé™¤ã—ã¦å€‹åˆ¥ã®æ›²ãƒ•ã‚¡ã‚¤ãƒ«ã¸åˆ†å‰²ã—ã¾ã™ã€‚</p>
    
    <div class="upload-area">
        <label for="fileInput" class="custom-file-upload">ğŸ“‚ TJAãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="fileInput">
        <div id="fileNameDisplay">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</div>
        <button id="processBtn">åˆ†è§£ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
    </div>

    <div id="logArea"></div>
</div>

<div class="footer">Powered by GitHub Pages | TJA-Decomposition-tool</div>

<script>
    const fileInput = document.getElementById('fileInput');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const processBtn = document.getElementById('processBtn');
    const logArea = document.getElementById('logArea');
    let selectedFile = null;

    function log(msg, type = 'info') {
        logArea.style.display = 'block';
        const div = document.createElement('div');
        div.className = `log-${type}`;
        div.textContent = `> ${msg}`;
        logArea.appendChild(div);
        logArea.scrollTop = logArea.scrollHeight;
    }

    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            selectedFile = e.target.files[0];
            fileNameDisplay.textContent = selectedFile.name;
            processBtn.style.display = "block";
            logArea.innerHTML = '';
            log("ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚", 'info');
        }
    });

    processBtn.addEventListener('click', async () => {
        if (!selectedFile) return;
        processBtn.disabled = true;
        log("å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...", 'info');

        try {
            // æ–‡å­—ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿ï¼ˆShift-JISå„ªå…ˆï¼‰
            let text = await readFileAsText(selectedFile, 'shift-jis');
            if (!text.includes('TITLE:') && !text.includes('title:') && !text.includes('#NEXTSONG')) {
                log("Shift-JISã§ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚UTF-8ã§å†è©¦è¡Œã—ã¾ã™ã€‚", 'warn');
                text = await readFileAsText(selectedFile, 'utf-8');
            }

            const lines = text.split(/\r?\n/);
            const zip = new JSZip();

            let songs = [];
            let currentSong = { lines: [], header: {} };
            let globalHeader = { balloon: [] }; 
            let isGlobalHeader = true;
            let balloonIndex = 0; 

            // --- 1. æ›²ã”ã¨ã®ãƒ–ãƒ­ãƒƒã‚¯åˆ†ã‘ ---
            for (let line of lines) {
                // BOMå‰Šé™¤
                if (line.charCodeAt(0) === 0xFEFF) line = line.substr(1);
                const trimLine = line.trim();

                // å…±é€šãƒ˜ãƒƒãƒ€ã®BALLOONå–å¾—
                if (isGlobalHeader && trimLine.toUpperCase().startsWith('BALLOON:')) {
                    const val = trimLine.substring(8).trim();
                    if (val) {
                        globalHeader.balloon = val.split(/[,ã€]/).map(n => parseInt(n.trim()) || 0);
                        log(`å…±é€šé¢¨èˆ¹ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡º: ${globalHeader.balloon.length}å€‹`, 'info');
                    }
                }

                // æ›²åŒºåˆ‡ã‚Šæ¤œçŸ¥ (#NEXTSONG)
                const isNextSong = trimLine.toUpperCase().startsWith('#NEXTSONG');
                
                // 1æ›²ç›®ã®é–‹å§‹æ¤œçŸ¥ (#START)
                if (isGlobalHeader && trimLine.toUpperCase().startsWith('#START')) {
                    isGlobalHeader = false;
                }

                if (isNextSong) {
                    songs.push(currentSong);
                    currentSong = { lines: [], nextSongTag: trimLine };
                    isGlobalHeader = false;
                } else {
                    currentSong.lines.push(line);
                }
            }
            if (currentSong.lines.length > 0) {
                songs.push(currentSong);
            }

            log(`åˆè¨ˆ ${songs.length} ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œå‡ºã€‚å¤‰æ›ã‚’é–‹å§‹ã—ã¾ã™ã€‚`, 'info');

            // --- 2. å„æ›²ãƒ‡ãƒ¼ã‚¿ã®åŠ å·¥ ---
            let currentBpm = 0;

            for (let i = 0; i < songs.length; i++) {
                const song = songs[i];
                let outputLines = [];
                let songTitle = `Song_${i+1}`;
                let songWave = "";
                
                // 1æ›²ç›®ã‹ãã‚Œä»¥å¤–ã‹ã§åˆ†å²
                if (i === 0) {
                    // 1æ›²ç›®ã¯å…ƒã®ãƒ˜ãƒƒãƒ€æƒ…å ±ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
                    song.lines.forEach(l => {
                        if (l.toUpperCase().startsWith('BPM:')) currentBpm = parseFloat(l.split(':')[1]);
                        if (l.toUpperCase().startsWith('TITLE:')) songTitle = l.split(':')[1].trim();
                        if (l.toUpperCase().startsWith('WAVE:')) songWave = l.split(':')[1].trim();
                    });
                    
                    // 1æ›²ç›®ã®è¡Œã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŒã€EXAMãªã©ã¯é™¤å»ã™ã‚‹
                    song.lines.forEach(l => {
                        if (shouldKeepLine(l)) outputLines.push(l);
                    });

                } else {
                    // 2æ›²ç›®ä»¥é™: #NEXTSONGã‹ã‚‰æƒ…å ±æŠ½å‡º
                    // å¼•æ•°: Title, Sub, Genre, Wave, ScoreInit, ScoreDiff
                    // â€»EXAMãªã©ãŒå¼•æ•°ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã‚‚ã€ã“ã‚Œä»¥é™ã®å¼•æ•°ã¯ç„¡è¦–ã•ã‚Œã‚‹ã®ã§OK
                    const args = parseNextSong(song.nextSongTag);
                    
                    songTitle = args[0] || `Song_${i+1}`;
                    const subTitle = args[1] || "";
                    const genre = args[2] || "";
                    songWave = args[3] || "";
                    const scoreInit = args[4] || "";
                    const scoreDiff = args[5] || "";
                    
                    // BPMè¿½è·¡
                    let myBpm = currentBpm;
                    const bpmChangeLine = song.lines.find(l => l.trim().toUpperCase().startsWith('#BPMCHANGE'));
                    if (bpmChangeLine) {
                        const parts = bpmChangeLine.trim().split(/\s+/);
                        if (parts[1]) myBpm = parseFloat(parts[1]);
                    }

                    // ãƒ˜ãƒƒãƒ€ç”Ÿæˆ
                    outputLines.push(`TITLE:${songTitle}`);
                    outputLines.push(`SUBTITLE:${subTitle}`);
                    outputLines.push(`BPM:${myBpm}`);
                    outputLines.push(`WAVE:${songWave}`);
                    outputLines.push(`OFFSET:`);
                    outputLines.push(`SONGVOL:100`);
                    outputLines.push(`SEVOL:100`);
                    outputLines.push(`SCOREMODE:2`);
                    outputLines.push(`GENRE:${genre}`);
                    outputLines.push(`DEMOSTART:`);
                    outputLines.push(``);
                    outputLines.push(`COURSE:Oni`);
                    outputLines.push(`LEVEL:10`);
                    
                    // é¢¨èˆ¹å‰²ã‚Šå½“ã¦
                    const balloonCount = countBalloons(song.lines);
                    if (balloonCount > 0) {
                        const myBalloons = globalHeader.balloon.slice(balloonIndex, balloonIndex + balloonCount);
                        outputLines.push(`BALLOON:${myBalloons.join(',')}`);
                        balloonIndex += balloonCount;
                    } else {
                        outputLines.push(`BALLOON:`);
                    }

                    outputLines.push(`SCOREINIT:${scoreInit}`);
                    outputLines.push(`SCOREDIFF:${scoreDiff}`);
                    outputLines.push(``);

                    // è­œé¢ãƒ‡ãƒ¼ã‚¿è¿½åŠ ï¼ˆEXAMé™¤å»ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨ï¼‰
                    song.lines.forEach(l => {
                        if (shouldKeepLine(l)) {
                            outputLines.push(l);
                        } else {
                            // ãƒ‡ãƒãƒƒã‚°ç”¨ã«ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ã¯å‡ºã™
                            // console.log("Removed:", l); 
                        }
                    });
                }

                // æ¬¡ã®æ›²ã®ãŸã‚ã«BPMæ›´æ–°
                song.lines.forEach(l => {
                    if (l.trim().toUpperCase().startsWith('#BPMCHANGE')) {
                         const parts = l.trim().split(/\s+/);
                         if(parts[1]) currentBpm = parseFloat(parts[1]);
                    }
                });

                // ZIPã¸è¿½åŠ 
                const safeTitle = songTitle.replace(/[\\/*?:"<>|]/g, "_") || "Untitled";
                zip.file(`${i+1}_${safeTitle}.tja`, outputLines.join("\n"));
                log(`è¿½åŠ : ${safeTitle}`, 'success');
            }

            const content = await zip.generateAsync({type:"blob"});
            const downloadLink = document.createElement("a");
            downloadLink.href = URL.createObjectURL(content);
            const baseName = selectedFile.name.replace(/\.[^/.]+$/, "");
            downloadLink.download = `${baseName}_split.zip`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            log("å®Œäº†ï¼", 'success');

        } catch (err) {
            console.error(err);
            log(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error');
        } finally {
            processBtn.disabled = false;
        }
    });

    // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
    function readFileAsText(file, encoding) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file, encoding);
        });
    }

    // NEXTSONGå¼•æ•°ãƒ‘ãƒ¼ã‚¹
    function parseNextSong(line) {
        const content = line.replace(/^#NEXTSONG\s+/i, '');
        return content.split(',').map(s => s.trim());
    }

    // ä¿å­˜ã™ã‚‹ã‹ã©ã†ã‹ã®åˆ¤å®šï¼ˆEXAMå‰Šé™¤ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
    function shouldKeepLine(line) {
        const t = line.trim().toUpperCase();
        
        // å‰Šé™¤å¯¾è±¡1: EXAMã‹ã‚‰å§‹ã¾ã‚‹è¡Œ (ä¾‹: EXAM1:jg,100)
        if (t.startsWith('EXAM')) return false;

        // å‰Šé™¤å¯¾è±¡2: LEVELHOLD (æ®µä½ã‚²ãƒ¼ã‚¸ç¶­æŒã‚³ãƒãƒ³ãƒ‰)
        if (t.startsWith('#LEVELHOLD')) return false;

        // ãã®ä»–ã®æ®µä½ç”¨ã‚³ãƒãƒ³ãƒ‰ãŒã‚ã‚Œã°ã“ã“ã«è¿½åŠ å¯èƒ½
        
        return true;
    }

    // é¢¨èˆ¹ã‚«ã‚¦ãƒ³ãƒˆ
    function countBalloons(lines) {
        let count = 0;
        let isBody = false;
        for (let line of lines) {
            const t = line.trim().toUpperCase();
            if (t.startsWith('#START')) isBody = true;
            if (t.startsWith('#END')) isBody = false;
            
            if (isBody) {
                let cleanLine = line.split('//')[0];
                if (cleanLine.trim().startsWith('#')) continue;
                for (let char of cleanLine) {
                    if (char === '7' || char === '9') count++;
                }
            }
        }
        return count;
    }
</script>
</body>
</html>
