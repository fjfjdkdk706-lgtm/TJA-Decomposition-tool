<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TJA Decomposition Tool (Universal)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; background-color: #f4f6f8; line-height: 1.6; }
        .container { background-color: white; padding: 2.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h1 { color: #2d3748; margin-bottom: 0.5rem; text-align: center; }
        p.desc { text-align: center; color: #718096; margin-bottom: 2rem; font-size: 0.95rem; }
        
        .upload-area { 
            padding: 2rem; border: 2px dashed #cbd5e0; border-radius: 8px; background-color: #f8fafc; 
            text-align: center; transition: all 0.2s;
        }
        .upload-area:hover { border-color: #4299e1; background-color: #ebf8ff; }
        
        input[type="file"] { display: none; }
        .custom-file-upload {
            display: inline-block; padding: 12px 24px; cursor: pointer;
            background-color: #4a5568; color: white; border-radius: 6px; font-weight: bold;
            transition: background 0.2s;
        }
        .custom-file-upload:hover { background-color: #2d3748; }

        #fileNameDisplay { margin: 1rem 0; font-weight: bold; color: #3182ce; min-height: 1.5em; }

        #processBtn {
            background-color: #3182ce; color: white; border: none; padding: 14px 40px; 
            font-size: 1.1rem; font-weight: bold; border-radius: 6px; cursor: pointer; 
            transition: background-color 0.2s; display: none; margin: 10px auto;
        }
        #processBtn:hover { background-color: #2b6cb0; }

        #logArea {
            margin-top: 2rem; padding: 1rem; background-color: #2d3748; color: #a0aec0;
            border-radius: 6px; font-family: monospace; font-size: 0.85rem;
            max-height: 300px; overflow-y: auto; text-align: left; display: none;
        }
        .log-info { color: #63b3ed; }
        .log-success { color: #68d391; }
        .log-warn { color: #f6e05e; }
        .log-error { color: #fc8181; }

        .footer { margin-top: 2rem; font-size: 0.8rem; color: #a0aec0; text-align: center; }
    </style>
</head>
<body>

<div class="container">
    <h1>TJA Decomposition Tool</h1>
    <p class="desc">æ®µä½TJA(TNDE/OpenTaikoå¯¾å¿œ)ã‚’è§£æã—ã€EXAMé™¤å»ï¼†æ­£ã—ã„é›£æ˜“åº¦è¨­å®šã§åˆ†å‰²ã—ã¾ã™ã€‚</p>
    
    <div class="upload-area">
        <label for="fileInput" class="custom-file-upload">ğŸ“‚ TJAãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
        <input type="file" id="fileInput">
        <div id="fileNameDisplay">ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“</div>
        <button id="processBtn">åˆ†è§£ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
    </div>

    <div id="logArea"></div>
</div>

<div class="footer">Powered by GitHub Pages | TJA-Decomposition-tool</div>

<script>
    const fileInput = document.getElementById('fileInput');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const processBtn = document.getElementById('processBtn');
    const logArea = document.getElementById('logArea');
    let selectedFile = null;

    function log(msg, type = 'info') {
        logArea.style.display = 'block';
        const div = document.createElement('div');
        div.className = `log-${type}`;
        div.textContent = `> ${msg}`;
        logArea.appendChild(div);
        logArea.scrollTop = logArea.scrollHeight;
    }

    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
            selectedFile = e.target.files[0];
            fileNameDisplay.textContent = selectedFile.name;
            processBtn.style.display = "block";
            logArea.innerHTML = '';
            log("ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¾ã—ãŸã€‚", 'info');
        }
    });

    processBtn.addEventListener('click', async () => {
        if (!selectedFile) return;
        processBtn.disabled = true;
        log("å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™...", 'info');

        try {
            // æ–‡å­—ã‚³ãƒ¼ãƒ‰èª­ã¿è¾¼ã¿
            let text = await readFileAsText(selectedFile, 'shift-jis');
            if (!text.includes('TITLE:') && !text.includes('title:') && !text.includes('#NEXTSONG')) {
                log("UTF-8ã§å†è©¦è¡Œã—ã¾ã™ã€‚", 'warn');
                text = await readFileAsText(selectedFile, 'utf-8');
            }

            const lines = text.split(/\r?\n/);
            const zip = new JSZip();

            let songs = [];
            let currentSong = { lines: [], header: {} };
            let globalHeader = { balloon: [] }; 
            let isGlobalHeader = true;
            let balloonIndex = 0; 

            // --- 1. ãƒ–ãƒ­ãƒƒã‚¯åˆ†ã‘ ---
            for (let line of lines) {
                if (line.charCodeAt(0) === 0xFEFF) line = line.substr(1);
                const trimLine = line.trim();

                if (isGlobalHeader && trimLine.toUpperCase().startsWith('BALLOON:')) {
                    const val = trimLine.substring(8).trim();
                    if (val) globalHeader.balloon = val.split(/[,ã€]/).map(n => parseInt(n.trim()) || 0);
                }

                const isNextSong = trimLine.toUpperCase().startsWith('#NEXTSONG');
                
                if (isGlobalHeader && trimLine.toUpperCase().startsWith('#START')) {
                    isGlobalHeader = false;
                }

                if (isNextSong) {
                    songs.push(currentSong);
                    currentSong = { lines: [], nextSongTag: trimLine };
                    isGlobalHeader = false;
                } else {
                    currentSong.lines.push(line);
                }
            }
            if (currentSong.lines.length > 0) songs.push(currentSong);

            log(`åˆè¨ˆ ${songs.length} æ›²ã‚’æ¤œå‡ºã€‚`, 'info');

            // --- 2. ãƒ‡ãƒ¼ã‚¿åŠ å·¥ã¨åˆ†å‰² ---
            let currentBpm = 0;

            for (let i = 0; i < songs.length; i++) {
                const song = songs[i];
                let outputLines = [];
                let songTitle = `Song_${i+1}`;
                let songWave = "";
                let courseStr = "Oni"; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                let levelStr = "10";   // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                
                // 1æ›²ç›®
                if (i === 0) {
                    song.lines.forEach(l => {
                        if (l.toUpperCase().startsWith('BPM:')) currentBpm = parseFloat(l.split(':')[1]);
                        if (l.toUpperCase().startsWith('TITLE:')) songTitle = l.split(':')[1].trim();
                        if (l.toUpperCase().startsWith('WAVE:')) songWave = l.split(':')[1].trim();
                    });
                    song.lines.forEach(l => {
                        if (shouldKeepLine(l)) outputLines.push(l);
                    });

                } else {
                    // 2æ›²ç›®ä»¥é™: #NEXTSONGè§£æ (TNDE vs OpenTaiko åˆ¤åˆ¥ãƒ­ã‚¸ãƒƒã‚¯å…¥ã‚Š)
                    // args: [Title, Sub, Genre, Wave, Init, Diff, ArgA, ArgB]
                    const args = parseNextSong(song.nextSongTag);
                    
                    songTitle = args[0] || `Song_${i+1}`;
                    const subTitle = args[1] || "";
                    const genre = args[2] || "";
                    songWave = args[3] || "";
                    const scoreInit = args[4] || "";
                    const scoreDiff = args[5] || "";

                    // â˜…ã‚³ãƒ¼ã‚¹ã¨ãƒ¬ãƒ™ãƒ«ã®è‡ªå‹•åˆ¤åˆ¥â˜…
                    if (args.length >= 8) {
                        const valA = parseFloat(args[6]); // 7ç•ªç›®ã®å¼•æ•°
                        const valB = parseFloat(args[7]); // 8ç•ªç›®ã®å¼•æ•°
                        
                        // åˆ¤åˆ¥ãƒ­ã‚¸ãƒƒã‚¯:
                        // ã‚³ãƒ¼ã‚¹IDã¯ 0ï½4 (Easy, Normal, Hard, Oni, Edit)
                        // ãƒ¬ãƒ™ãƒ«ã¯é€šå¸¸ 1ï½10 (ãã‚Œä»¥ä¸Šã‚‚ã‚ã‚Šãˆã‚‹)
                        // valAãŒ5ä»¥ä¸Šãªã‚‰ã€valAã¯ãƒ¬ãƒ™ãƒ«(OpenTaikoå½¢å¼)ã§ã‚ã‚‹å¯èƒ½æ€§ãŒé«˜ã„
                        
                        if (valA > 4) {
                            // OpenTaikoå½¢å¼: Level, Course
                            levelStr = args[6];
                            courseStr = mapCourseId(args[7]);
                        } else {
                            // TNDEå½¢å¼: Course, Level (ã¾ãŸã¯ä¸¡æ–¹å°ã•ã„å ´åˆã¯ã“ã¡ã‚‰ã‚’å„ªå…ˆ)
                            courseStr = mapCourseId(args[6]);
                            levelStr = args[7];
                        }
                    }

                    // BPMè¿½è·¡
                    let myBpm = currentBpm;
                    const bpmChangeLine = song.lines.find(l => l.trim().toUpperCase().startsWith('#BPMCHANGE'));
                    if (bpmChangeLine) {
                        const parts = bpmChangeLine.trim().split(/\s+/);
                        if (parts[1]) myBpm = parseFloat(parts[1]);
                    }

                    outputLines.push(`TITLE:${songTitle}`);
                    outputLines.push(`SUBTITLE:${subTitle}`);
                    outputLines.push(`BPM:${myBpm}`);
                    outputLines.push(`WAVE:${songWave}`);
                    outputLines.push(`OFFSET:`);
                    outputLines.push(`SONGVOL:100`);
                    outputLines.push(`SEVOL:100`);
                    outputLines.push(`SCOREMODE:2`);
                    outputLines.push(`GENRE:${genre}`);
                    outputLines.push(`DEMOSTART:`);
                    outputLines.push(``);
                    outputLines.push(`COURSE:${courseStr}`);
                    outputLines.push(`LEVEL:${levelStr}`);
                    
                    // é¢¨èˆ¹å‡¦ç†
                    const balloonCount = countBalloons(song.lines);
                    if (balloonCount > 0) {
                        const myBalloons = globalHeader.balloon.slice(balloonIndex, balloonIndex + balloonCount);
                        outputLines.push(`BALLOON:${myBalloons.join(',')}`);
                        balloonIndex += balloonCount;
                    } else {
                        outputLines.push(`BALLOON:`);
                    }

                    outputLines.push(`SCOREINIT:${scoreInit}`);
                    outputLines.push(`SCOREDIFF:${scoreDiff}`);
                    outputLines.push(``);

                    song.lines.forEach(l => {
                        if (shouldKeepLine(l)) outputLines.push(l);
                    });
                }

                // æ¬¡æ›²ã®ãŸã‚BPMæ›´æ–°
                song.lines.forEach(l => {
                    if (l.trim().toUpperCase().startsWith('#BPMCHANGE')) {
                         const parts = l.trim().split(/\s+/);
                         if(parts[1]) currentBpm = parseFloat(parts[1]);
                    }
                });

                // ä¿å­˜
                const safeTitle = songTitle.replace(/[\\/*?:"<>|]/g, "_") || "Untitled";
                const safeDifficulty = (courseStr === "Edit" || courseStr === "4") ? "_Ura" : ""; // è£è­œé¢ãªã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã«ä»˜ã‘ã‚‹
                zip.file(`${i+1}_${safeTitle}${safeDifficulty}.tja`, outputLines.join("\n"));
                log(`è¿½åŠ : ${safeTitle} (${courseStr} â˜…${levelStr})`, 'success');
            }

            const content = await zip.generateAsync({type:"blob"});
            const downloadLink = document.createElement("a");
            downloadLink.href = URL.createObjectURL(content);
            const baseName = selectedFile.name.replace(/\.[^/.]+$/, "");
            downloadLink.download = `${baseName}_split.zip`;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);

            log("å®Œäº†ï¼", 'success');

        } catch (err) {
            console.error(err);
            log(`ã‚¨ãƒ©ãƒ¼: ${err.message}`, 'error');
        } finally {
            processBtn.disabled = false;
        }
    });

    function readFileAsText(file, encoding) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file, encoding);
        });
    }

    function parseNextSong(line) {
        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§åˆ†å‰²ã—ã€ç©ºç™½ã‚’é™¤å»
        const content = line.replace(/^#NEXTSONG\s+/i, '');
        return content.split(',').map(s => s.trim());
    }

    function mapCourseId(idStr) {
        // IDã‚’ãƒ†ã‚­ã‚¹ãƒˆ(Oniãªã©)ã«å¤‰æ›
        const id = parseInt(idStr);
        switch(id) {
            case 0: return "Easy";
            case 1: return "Normal";
            case 2: return "Hard";
            case 3: return "Oni";
            case 4: return "Edit";
            default: return "Oni"; // ä¸æ˜æ™‚ã¯Oni
        }
    }

    function shouldKeepLine(line) {
        const t = line.trim().toUpperCase();
        if (t.startsWith('EXAM')) return false;      // EXAMå‰Šé™¤
        if (t.startsWith('#LEVELHOLD')) return false; // LEVELHOLDå‰Šé™¤
        return true;
    }

    function countBalloons(lines) {
        let count = 0;
        let isBody = false;
        for (let line of lines) {
            const t = line.trim().toUpperCase();
            if (t.startsWith('#START')) isBody = true;
            if (t.startsWith('#END')) isBody = false;
            
            if (isBody) {
                let cleanLine = line.split('//')[0];
                if (cleanLine.trim().startsWith('#')) continue;
                for (let char of cleanLine) {
                    if (char === '7' || char === '9') count++;
                }
            }
        }
        return count;
    }
</script>
</body>
</html>
