<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>段位TJA分割＆音声同梱ツール</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        #drop-zone {
            width: 100%; height: 200px;
            border: 3px dashed #ccc;
            border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            color: #666; font-size: 1.2em; margin-bottom: 20px;
            background-color: #f9f9f9;
        }
        #drop-zone.hover { border-color: #333; background-color: #e9e9e9; }
        button { padding: 10px 20px; font-size: 1em; cursor: pointer; }
        #log { margin-top: 20px; white-space: pre-wrap; background: #eee; padding: 10px; border-radius: 5px;}
    </style>
</head>
<body>

    <h1>段位フォルダ分割ツール</h1>
    <p>段位のフォルダ（TJAと音声が入ったもの）をここにドラッグ＆ドロップしてください。<br>
    イントロ（1つ目の区切り）を削除し、2曲目以降を音声セットにしてZIP化します。</p>

    <div id="drop-zone">ここにフォルダをドロップ</div>
    
    <div id="log">待機中...</div>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const logDiv = document.getElementById('log');

        // ドラッグ＆ドロップのイベント制御
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('hover');
        });
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('hover');
        });
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('hover');
            const items = e.dataTransfer.items;
            if (!items) return;
            
            log("ファイルを解析中...");
            await handleDrop(items);
        });

        function log(text) {
            logDiv.textContent += text + "\n";
            console.log(text);
        }

        async function handleDrop(items) {
            const filesMap = new Map(); // ファイル名 -> Fileオブジェクト
            let tjaFile = null;

            // 1. ファイル走査 (再帰的にフォルダを読む)
            const entries = [];
            for (let i = 0; i < items.length; i++) {
                const entry = items[i].webkitGetAsEntry();
                if (entry) entries.push(entry);
            }
            
            await traverseFileTree(entries, filesMap);

            // TJAファイルを探す
            for (const [name, file] of filesMap) {
                if (name.toLowerCase().endsWith('.tja')) {
                    tjaFile = file;
                    break; // 最初に見つかったTJAを対象とする
                }
            }

            if (!tjaFile) {
                log("エラー: .tjaファイルが見つかりませんでした。");
                return;
            }

            log(`TJAファイル検出: ${tjaFile.name}`);
            processTjaAndZip(tjaFile, filesMap);
        }

        // フォルダ内部を再帰的に読み込む
        async function traverseFileTree(entries, filesMap) {
            for (const entry of entries) {
                if (entry.isFile) {
                    const file = await new Promise((resolve) => entry.file(resolve));
                    // マップにはファイル名だけで登録（パスは無視してフラットに扱う場合）
                    // ※同名ファイルがある場合は上書きされるので注意
                    filesMap.set(file.name, file);
                } else if (entry.isDirectory) {
                    const dirReader = entry.createReader();
                    const newEntries = await new Promise((resolve) => dirReader.readEntries(resolve));
                    await traverseFileTree(newEntries, filesMap);
                }
            }
        }

        async function processTjaAndZip(tjaFile, filesMap) {
            const reader = new FileReader();
            
            // 重要: 日本語TJAは Shift_JIS の可能性が高いが、最近は UTF-8 もある。
            // ここでは一旦 Shift_JIS として読み込む実装例（必要に応じて変更）
            reader.readAsText(tjaFile, 'Shift_JIS'); 

            reader.onload = async (e) => {
                const content = e.target.result;
                const zip = new JSZip();

                // 2. TJAを #NEXTSONG で分割
                // 正規表現で分割（行頭の#NEXTSONGを検知）
                const parts = content.split(/^#NEXTSONG.*$/m);

                log(`セクション数: ${parts.length} (イントロ含む)`);

                if (parts.length < 2) {
                    log("エラー: #NEXTSONG が見つかりません。分割できませんでした。");
                    return;
                }

                // 3. 共通ヘッダ（BALLOONなど）の抽出
                // 1つ目のパート(イントロ)から、ヘッダ情報(TITLE, WAVE以外)を抽出して保持する
                const firstPartLines = parts[0].split(/\r?\n/);
                let commonHeader = "";
                
                // 必要なヘッダタグ（BALLOON等は必須。TITLEやWAVEは各曲で上書きされるので除外しても良いが、念のためTITLE/WAVE以外を集める）
                // ※BPMやOFFSETは各曲定義が優先されるが、初期値として持っておく
                firstPartLines.forEach(line => {
                    const l = line.trim();
                    if (l.startsWith("BALLOON:") || l.startsWith("COURSE:") || l.startsWith("LEVEL:") || l.startsWith("SCOREMODE:")) {
                        commonHeader += line + "\n";
                    }
                });

                log("共通ヘッダ情報(BALLOON等)を抽出しました。");

                // 4. 2つ目以降のパートを処理 (index 1 から開始 = イントロ削除)
                for (let i = 1; i < parts.length; i++) {
                    let partContent = parts[i];
                    
                    // 共通ヘッダを先頭に付与
                    // 元のpartContentの先頭に改行があるかもしれないので整形
                    let newTjaContent = commonHeader + "\n" + partContent;

                    // WAVE: ◯◯.ogg を探す
                    const waveMatch = partContent.match(/^WAVE:(.+)$/m);
                    let audioFileName = null;
                    let audioFileObj = null;

                    if (waveMatch) {
                        audioFileName = waveMatch[1].trim();
                        // 拡張子の前後に余計な空白がある場合の対策や、パス区切りの除去
                        audioFileName = audioFileName.split(/[/\\]/).pop(); 
                        
                        if (filesMap.has(audioFileName)) {
                            audioFileObj = filesMap.get(audioFileName);
                            log(`[曲 ${i}] 音声特定: ${audioFileName}`);
                        } else {
                            log(`[曲 ${i}] 警告: 音声ファイル ${audioFileName} がアップロードされたフォルダに見つかりません。`);
                        }
                    }

                    // 5. ZIPに追加
                    // フォルダ分け: "Song_1", "Song_2" ...
                    const folderName = `Song_${i}`;
                    const folder = zip.folder(folderName);

                    // TJA書き出し
                    folder.file(`song_${i}.tja`, newTjaContent);

                    // 音声書き出し（見つかっていれば）
                    if (audioFileObj) {
                        folder.file(audioFileName, audioFileObj);
                    }
                }

                // 6. ZIP生成とダウンロード
                log("ZIP圧縮中...");
                const blob = await zip.generateAsync({type:"blob"});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = "split_dani_songs.zip";
                link.click();
                log("ダウンロードを開始しました！");
            };
        }
    </script>
</body>
</html>
